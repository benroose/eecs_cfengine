###############################################################################
#
#   manage/ssh/main.cf - EECS ssh/sshd configuration
#   Maintained: Ben Roose, ver 0.1
#
###############################################################################

#PRO TIP:
# better to describe the state you are in than the state you want to
# obtain. Because when reading the policy to restart it can be nice to
# know why your restarting, instead of restarting because someone said restart.

#body file control
#{
#      inputs => { "$(sys.libdir)/stdlib.cf" };
#}

######################################################################
# Public entry point: config_sshd
######################################################################

# NOTES for future development of configuration:
# Consider managing a temporary file that can be validated with sshd -t -c
# If that check returns zero then you can promise that the real sshd config
# is a copy of the validated file. and then define the class used to restart
# if the main config is repaired by the copy from the validated temporary
# file. This improves resilience, and tries to avoid deploying a potentially
# broken config.bundle agent configfiles

bundle agent config_sshd
{
  vars:  
      # Files to edit
      "files[sshd]"   string => "/etc/ssh/sshd_config";

      # SSHD configuration to set
      "sshd[Port]"                                    string => "22";
      "sshd[X11Forwarding]"                           string => "yes";
      "sshd[UseDNS]"                                  string => "no";
      "sshd[PermitRootLogin]"                         string => "no";
      
  methods:
      "sshd"    usebundle => edit_sshd;

  reports:
    (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_config_files)::
      
}

bundle agent edit_sshd
{
  files:
      "$(config_sshd.files[sshd])"
      handle => "edit_sshd",
      comment => "Set desired sshd parameters",
      edit_line => set_line_based("config_sshd.sshd", " ", "\s+", ".*", "\s*#\s*"),
      classes => results("bundle", "sshd");

  methods:
    sshd_repaired.debian.!no_restarts::
      "debian reload sshd service if config file modified" usebundle => standard_services("sshd", "reload"),
      classes => results("bundle", "sshd_reload");

    sshd_repaired.redhat.!no_restarts::
      "redhat restart sshd service if config file modified" usebundle => standard_services("sshd", "restart"),
      classes => results("bundle", "sshd_restart");

  reports:
    (DEBUG|DEBUG_config_files).sshd_reload_repaired::
      "sshd service reloaded after $(config_sshd.files[sshd]) file repaired";
    (DEBUG|DEBUG_config_files).sshd_restart_repaired::
      "sshd service restarted after $(config_sshd.files[sshd]) file repaired";
}
