###############################################################################
#
#   manage/iptables/main.cf - EECS iptables configuration
#   Maintained: Ben Roose, ver 0.1
#
###############################################################################

# PROTIP: Use body file control to help make modular policy.
# "There can be only one" body common control per policy entry (promises.cf,
# update.cf)

body file control
{
	    inputs => { "$(sys.libdir)/stdlib.cf" };
}

bundle agent config_iptables
{

  vars:
      
    "iptables_data"
      data => readjson( "$(this.promise_dirname)/iptables_rules_server.json", 10M );

      #??"key" slist => getindices("iptables_data");


      "rule_numbers" slist => getindices("iptables_data[filter_rules]");
#      "rule_numbers" slist => sort(rule_numbers_unsorted, "int");
#      "rule_array" slist => getindices ("iptables_data[filter_rules][$(rule_numbers)]");
      "rule_array" data => mergedata ("iptables_data[filter_rules]");
#      "rule_array" data => mergedata ("iptables_data[filter_rules][$(rule_numbers)]");

  methods:
      # pass the container and a key inside it
            "any" usebundle => analyze(@(rule_array), $(rule_numbers));
      #$($(params)[_install_dir])

      #"chain_policies" data => mergedata( "iptables_data[chain_policies]" );
      #"filter_rules" slist => getvalues( "iptables_data[filter_rules][$(rules)]" );
      #"chain_str" string => format("%S", $(chain_policies));
      #"filter_str" string => format("%S", $(filter_rules));

      #"json_str" string => format("%S", iptables_data);
                       # Just for printing seralized version of data container
                       # for debugging (note it is JSON).

# You needed to switch to a methods type promise here.
      #"iptables_filter"
      #  usebundle => iptables_filter( $(chain_policies), $(filter_rules) ),
      #  comment => "pass policies and rules read in from external file onto the iptables subfunctions.";

# *Note:* bundles are *not* functions. They are collections of promises.
# See if you can grok this: https://gist.github.com/563a4f986e1edd88c106610581bfc456

# In summary: if you plan to actuate a bundle more than once (and you want or
# need it to behave like a function), you need to account for making all
# promises unique.

# Remember once a promise has been kept or repaired, it won't be actuated again
# within the same agent run.

# Also remember that each time a bundle is actuated it gets 3 passes to
# converge. So if you try to write a bunch of tiny utility bundles that you call
# over and over just be aware of the extra work the agent is performing for that
# style of abstraction.

  reports:
#####
# Notes from Nick's json example here (unrelated but just for reference):
#    "Webserver Owner: $(d[webserver][owner])";
#    "Key = '$(keys)' location='$(d[$(keys)][location])', owner='$(d[$(keys)][owner])'";
#####

    (DEBUG|DEBUG_main)::
     # "I want the var 'chain_policies' to be defined as array with all content $() for sending onto subfunctions";
      "List rules to be defined as $(rule_numbers) and 'rule_array' to be defined as $(rule_array)";

#      "Contents of 'json_input' data container: '$(json_str)'";
}

bundle agent analyzeold(rules, key)
{
  vars:
      "rule_name" slist => getindices("rules[$(key)]");
#      "names_str" string => format("%S", rule_name);

  reports:
#      "$(this.bundle): rule_name for filter '$(key)': $(names_str)";
#      "$(this.bundle): rule '$(key)' => $(rule_name) = $(rules[$(rule_name)])";
      "$(this.bundle): rule '$(key)' => $(rule_name) = $(rules[$(key)][$(rule_name)])";

}

bundle agent analyze(rules, key)
{
  vars:
      "rule_attribute" slist => getindices("rules[$(key)]");
      "rule_value" slist => getvalues("rules[$(key)]"); #SORT?
#      "names_str" string => format("%S", rule_name);
#      "rule_array" string => $(rules[$(key)][$(rule_name)]

  reports:
 #     "$(this.bundle): rule_name for filter '$(key)': $(names_str)";
      "$(this.bundle): $(rule_attribute)";
#      "$(this.bundle): $(rule_attribute) = $(rule_value)";
}


bundle agent iptables_filter(chain_policies, rules, rules_key)
{
  vars:
      "_cache_dir" string => "$(sys.workdir)/cache/security/iptables/filter";

      "filter_rules" slist => getindices("rules[$(rules_key)]");
      
  methods:

    any::
      "DUMP CURRENT ACTIVE RULES"
      usebundle => iptables_dump($(_cache_dir)),
      inherit => "true",
      handle => "iptables_dump";

      "CHECK IPTABLES RULES AND APPLY"
      inherit => "true",
      usebundle => iptables_check($(_cache_dir), $(chain_policies), $(filter_rules));

#      "TIDY TEMP FILES"
#      inherit => "true",
#      usebundle => iptables_tidy($(_cache_dir)),
#      handle => "iptables_tidy";
}

bundle agent iptables_check(cdir, chain_policies,filter_rules) {

  files:
      "$(cdir)/cf.iptables.filter.policy"
      create => "true",
      edit_defaults => empty,
      edit_line => iptables_write_policy($(chain_policies),$(filter_rules)),
      handle => "edit_iptables_filter",
      comment => "generate the new policy file";

      "$(cdir)/cf.iptables.filter.current"
      copy_from => local_dcp("$(cdir)/cf.iptables.filter.policy"),
      classes => if_repaired("iptables_filter_repaired");

  commands:
      "/sbin/iptables-restore < $(cdir)/cf.iptables.filter.policy"
      contain => in_shell,
      ifvarclass => "iptables_filter_repaired";
}

bundle agent iptables_dump(cdir)
{
  commands:
      "/sbin/iptables-save -t filter > $(cdir)/cf.iptables.filter.current"
      contain => in_shell,
      handle => canonify("iptables_filter_save"),
      depends_on => { "iptables_create_cache_dir" },
      comment => "save current iptables configuration as file to cache directory";

  files:
      "$(cdir)/."
      create => "true",
      handle => "iptables_create_cache_dir";

      "$(cdir)/cf.iptables.filter.current"
      depends_on => { "iptables_filter_save" },
      edit_defaults => no_backup,
      edit_line => iptables_clean_dump,
      comment => "remove all rules from current file";
}

bundle agent iptables_tidy(cdir)
{
  files:
      "$(cdir)/cf.iptables.filter.*"
      pathtype => "regex",
      delete => tidy;
}

bundle edit_line iptables_clean_dump
{
  # @description: removes all rules from configuration file?

  delete_lines:
      "^#.*";
  replace_patterns:
      "\s+\[\d+:\d+\]\s*$"
      replace_with => value("");
      "\s+$"
      replace_with => value("");
}

bundle edit_line iptables_write_policy(p,r)
# @description: takes in chain policies (p) and filter rules (r) as arrays and
# builds the iptables-restore input file
{

  vars:
      "i_nosort" slist => getindices($(r));
      # in 3.5.0 this can be done with sort()
      "i_nosort_concat" string => join( " ", "i_nosort" );
      "sorter" string => "/usr/bin/perl -le '$,=q{ };print sort { $a <=> $b } @ARGV'";
      "i_sort_tmp" string => execresult( "$(sorter) $(i_nosort_concat)", "noshell" );
      "i" slist => splitstring( $(i_sort_tmp), "\s+", "inf" );

      # Format input interface strings
      "cmnd[in_iface][$(i)]" string => "", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][interface]"));
      "cmnd[in_iface][$(i)]" string => " --i $($(r)[$(i)][interface])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][interface]"));

      #Format source IP strings
      "cmnd[s_ip][$(i)]" string => "", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][source_ip]"));
      "cmnd[s_ip][$(i)]" string => " -s $($(r)[$(i)][source_ip])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][source_ip]"));

      #Format destination IP strings
      "cmnd[d_ip][$(i)]" string => "", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][destination_ip]"));
      "cmnd[d_ip][$(i)]" string => " -d $($(r)[$(i)][destination_ip])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][destination_ip]"));

      # Format destination port strings
      "cmnd[d_port][$(i)]" string => "", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][destination_port]"));
      "cmnd[d_port][$(i)]" string => " --dport $($(r)[$(i)][destination_port])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][destination_port]"));

      # Format source port strings
      "cmnd[s_port][$(i)]" string => "", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][source_port]"));
      "cmnd[s_port][$(i)]" string => " --sport $($(r)[$(i)][source_port])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][source_port]"));

      # Add default protocol = tcp if not defined
      "cmnd[proto][$(i)]" string => "tcp", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][protocol]"));
      "cmnd[proto][$(i)]" string => "$($(r)[$(i)][protocol])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][protocol]"));

      # Add default chain = INPUT if not defined
      "cmnd[chain][$(i)]" string => "INPUT", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][chain]"));
      "cmnd[chain][$(i)]" string => "$($(r)[$(i)][chain])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][chain]"));

      # Add default target = ACCEPT if not defined
      "cmnd[target][$(i)]" string => "ACCEPT", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][target]"));
      "cmnd[target][$(i)]" string => "$($(r)[$(i)][target])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][target]"));

      # Add default context/class = any (always true) if not defined
      # USE: context will implement iptables rule only if specified class(s) is defined in CFEngine
      "cmnd[context][$(i)]" string => "any", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][context]"));
      "cmnd[context][$(i)]" string => "$($(r)[$(i)][context])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][context]"));

      # Extract comment if defined (for documentation and readability in originating .json file)
      # Currently comments are dropped here and not handled further. However, they could be pushed into iptables input file as a comment, or pushed onto a reporting/log bundle
      #"comment" string => "", policy => "free", ifvarclass => not(isvariable("$(r)[$(i)][comment]"));
      "comment" string => "$($(r)[$(i)][comment])", policy => "free", ifvarclass => and(isvariable("$(r)[$(i)][comment]"));

  insert_lines:
      "*filter";
      ":INPUT $($(p)[input])";
      ":FORWARD $($(p)[forward])";
      ":OUTPUT $($(p)[output])";
      "-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT";
      "-A $(cmnd[chain][$(i)])$(cmnd[in_iface])$(cmnd[s_ip][$(i)])$(cmnd[d_ip][$(i)]) -p $(cmnd[proto][$(i)]) -m $(cmnd[proto][$(i)])$(cmnd[s_port][$(i)])$(cmnd[d_port][$(i)]) -j $(cmnd[target][$(i)])"
      ifvarclass => and("$(cmnd[context][$(i)])");
      "COMMIT";
}
