##############################################################################
#
#   manage/nfs/main.cf - EECS nfs server install and configuration
#   Maintained: Ben Roose, ver 0.1
#
###############################################################################



# PROTIP: Use body file control to help make modular policy.
# "There can be only one" body common control per policy entry (promises.cf,update.cf)

# TESTING ONLY:INPUT STANDARD LIBRARY and HOST CLASSIFICATION (Remove after testing)
body file control
{
      inputs => { "$(sys.libdir)/stdlib.cf",
		  "$(sys.workdir)/inputs/services/eecs/classification/host_role/main.cf" };
}

######################################################################
# Public entry point: config_nfs_server
######################################################################

# NOTES for future development of configuration:
# 1.


bundle agent config_nfs_server
# @description: install and configure a simple tftpd-hda server
{
  vars:
      "dependent_packages" slist => { "nfs-kernel-server", "nfs-common" };

      "exports_file" string => "/tmp/exports"; # change to /etc/exports

      "canonified_host" string => canonify("$(sys.host)");

      "host_data" data => readjson("$(this.promise_dirname)/data/host_exports.json",1M),
        comment => "pull in external json file containing list of exports defined by hostname";
      
      "exports_data"
        data => mergedata( "host_data[$(canonified_host)]" ),
        ifvarclass => isvariable("host_data[$(canonified_host)]"),
        comment => "create data subset from host_exports.json file";

      "exports_json_str" string => format("%S", "group_data"),
        ifvarclass => isvariable("host_data[$(canonified_host)]");

      "exports_unsorted" slist => getindices( "exports_data" );
      "exports" slist => sort("exports_unsorted",lex);

      # "userdata_$(group)" data => mergedata("group_data[$(group)]");
      # "user[$(group)]" slist => getindices( "userdata_$(group)" );
      # "grader_user" slist => getindices("group_data[grader]");

      # "group_parent_dir" string => "/srv/";
      # "group_dir[$(group)]" string => concat ("$(group_parent_dir)", "$(group)");

      
      "tftp[TFTP_USERNAME]" string => "tftp";
      "tftp[TFTP_DIRECTORY]" string => "/srv/tftp";
      "tftp[TFTP_ADDRESS]" string => "0.0.0.0:69";
      "tftp[TFTP_OPTIONS]" string => "\"--create --secure\"";

  files:
      "$(exports)/."
	perms => mog("775", "root", "root" ),
        create => "true",
        comment => "ensure the directories for exporting have been created";

      # "$(tftp[TFTP_DIRECTORY])"
      # 	perms => mog("666", "$(tftp[TFTP_USERNAME])", "$(tftp[TFTP_USERNAME])" ),
      #   depth_search => recurse( "inf" ),
      #   comment => "ensure correct perms on any file within the tftp dir for tftp get/put";
      
  methods:
    install_software::
      "install dependent packages" usebundle => package_latest("$(dependent_packages)"),
        classes => results("bundle", "dependent_packages_installed");

    any::
      "edit the exports config file"  usebundle => edit_exports;
      
  reports:
    (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_config)::
      "=== $(this.bundle) ===";
      "$(tftpd_config) configured";

    (DEBUG|DEBUG_config).dependent_packages_installed_repaired::
      "$(dependent packages) installed";
}

######################################################################

bundle agent edit_exports
{
  files:
      "$(config_tftp_server.exports_file)"
      handle => "edit_exports",
      comment => "Make sure exports file contains desired directories and options for exporting",
      create => "true",
      edit_line => set_line_based("config_tftp_server.tftp", "=", "\s*=\s*", ".*", "\s*#\s*"),
      classes => results("bundle", "exports");

  services:
    exports_repaired.!no_restarts::
      "tftpd-hda"
      service_policy => "restart",
      handle => "tftpd_restart",
      comment => "Restart tftpd-hda if the configuration file was modified";
}
