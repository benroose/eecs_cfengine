##############################################################################
#
#   manage/repositories/main.cf - EECS package repository configuration
#   Maintained: Ben Roose, ver 0.3
#
###############################################################################



# PROTIP: Use body file control to help make modular policy.
# "There can be only one" body common control per policy entry (promises.cf,update.cf)

# TESTING ONLY:INPUT STANDARD LIBRARY and HOST CLASSIFICATION (Remove after testing)
body file control
{
	inputs => { "$(sys.libdir)/stdlib.cf",
 		    "$(sys.workdir)/inputs/services/eecs/classification/host_role/main.cf" };
}

######################################################################
# Public entry point: manage_repositories
######################################################################

# NOTES for future development of configuration:
# 1.

bundle agent manage_repositories
# @description: takes in repository info from external json file and adds or removes repository within /etc/apt/sources
{
  vars:
      "default_sources_file" string => "/etc/apt/sources.list";
      
      "options" string => "";

    debian.!ubuntu::
      "repositories_file" string => "$(this.promise_dirname)/data/repos_debian.json";

    ubuntu::
      "repositories_file" string => "$(this.promise_dirname)/data/repos_ubuntu.json";

    any::
      "repositories_data" data => readjson( $(repositories_file), 10M );
      "json_str" string => format("%S", repositories_data);

      "repos_ensure" data => mergedata("repositories_data[repos_to_ensure]");
      "repos_wipe" data => mergedata("repositories_data[repos_to_wipe]");      
     "json_str_ensure" string => format("%S", repos_ensure);
      
  methods:
    debian::
        "ensure all required repos are inserted into sources.list as specified in repos.json"
        	usebundle => ensure_repos( $(default_sources_file), @(repos_ensure), $(options) ),
          inherit => "true";

  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";
      

    (DEBUG|DEBUG_testing)::
      "=== $(this.bundle) ===";

    (DEBUG|DEBUG_testing).!debian::
      "Cannot set up repository sources on this operating system. Only have code for debian/ubuntu OS";
      # "Contents of 'json_input' data container: '$(json_str)'";  
      # "Contents of 'json_input_ensure' data container: '$(json_str_ensure)'";  
}

######################################################################
bundle agent ensure_repos(file, repo, options)
# @description: enforcing entries in /etc/apt/sources.list or /etc/apt/sources.list.d/*.list
{
  vars:
      "template_file" string => "$(this.promise_dirname)/data/sources_template.txt";

      "CFEnotice"
        string  => "# This file is managed by CFEngine, manual edits will be reverted",
        comment => "It's nice to let people know why the file keep magically reverting on them";

      "class_prefix" string => canonify($(file)),
        policy => "free";
      
      "i_unsorted" slist => getindices("repo");
      "index" slist => sort("i_unsorted",int),
	comment => "build a sorted index list of all ensured repo entries in each file";
      
  files:
      "$(file)"
        create        => "true",
        perms         => m("0644"),
	edit_defaults => backup_and_empty,
	edit_line     => repo_sources_list( $(CFEnotice), @(repo), $(options), @(index)),
        classes       => classes_generic("$(class_prefix)_ensure"),
        comment       => "edit $(file) adding repo entries and note that the file is managed by CFEngine";

  methods:
        "ensure all apt keys are inserted into keychain as specified in repos.json"
          usebundle => ensure_apt_key( @(repo), $(i),
          ifvarclass => and(isvariable("repo[$(i)][keyfile_link]", isvariable("repo[$(i)][context]")),
          inherit => "true";
      
  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_testing)::
      "=== $(this.bundle) ===";
      "repository sources file: $(file)";
}

######################################################################

bundle edit_line repo_sources_list(header, repo, options, i)
# @description: inserts entry lines from repo into the file
{
  vars:      
      "components_str[$(i)]" string => join(" ", "repo[$(i)][components]");

      "context[$(i)]" string => "any",
        ifvarclass => not(isvariable("repo[$(i)][context]"));
      "context[$(i)]" string => "$(repo[$(i)][context])",
        ifvarclass => and(isvariable("repo[$(i)][context]")),
      comment => "set context class for each ensure entry or set as any if not defined";

      "comment[$(i)]" string => "$(repro[$(i)][url])",
        ifvarclass => not(isvariable("repo[$(i)][comment]"));
      "comment[$(i)]" string => "$(repo[$(i)][comment])",
        ifvarclass => and(isvariable("repo[$(i)][comment]")),
      comment => "set comment for each ensure entry or set as [url] for reporting and logging";
      
      "entries[$(i)]" slist => maplist( "$(this) $(options) $(repo[$(i)][url]) $(repo[$(i)][distribution]) $(components_str[$(i)])", "repo[$(i)][types]" ),
      comment => "use maplist to set up each repo entry defined by index [i] and expand the list using [types]";

  # delete_lines:
  #     ".*";

  insert_lines:
      "$(header)$(const.n)";
      "# REPOSITORY SOURCES$(const.n)";
       "# $(context[$(i)])$(const.n)$(entries[$(i)])"
         ifvarclass => and("$(context[$(i)])");

  reports:
    (DEBUG|DEBUG_apt_sources)::
      "=== $(this.bundle) ===";
      "Comment for ensured repository $(i) = $(comment[$(i)])"
        ifvarclass => and("$(context[$(i)])");
}

######################################################################

body edit_defaults backup_and_empty
{
        empty_file_before_editing => "true";
        edit_backup => "true";
}

######################################################################

bundle agent ensure_apt_key(repo, i)
# @description: inserts entry lines from repo into the file
{

      # pseudocode:
      # 1 define vars
      # 2 pull in all custom fingerprints from json file
      # 3 get list of fingerprints from apt-key on system
      # 4 check custom fingerprints against apt-key list
      # 5 if a custom fingerprint is not in list
        # 1 download file from keyfile_link
        # 2 add keyfile with apt-key add

  vars:      
      "keyfile_link" string => "repo[$(i)][keyfile_link]";
      "keyfile_fingerprint" string => "repo[$(i)][keyfile_fingerprint]";

      # "keyfile_link[$(i)]" string => "",
      #   ifvarclass => not(isvariable("repo[$(i)][keyfile_link]"));
      # "keyfile_link[$(i)]" string => "$(repo[$(i)][keyfile_link])",
      #   ifvarclass => and(isvariable("repo[$(i)][keyfile_link]"));
      # "keyfile_fingerprint[$(i)]" string => "$(repo[$(i)][keyfile_fingerprint])",
      #   ifvarclass => and(isvariable("repo[$(i)][keyfile_fingerprint]")),
      #   comment => "set keyfile link and fingerprint for each ensure entry or set as null if not defined";
      
      "apt_key_list_cmd" string => "/usr/bin/apt-key finger | grep fingerprint";
      "apt_key_add_cmd" string => "/usr/bin/apt-key add ";
      "wget_cmd" string => "/usr/bin/wget -q --timeout=10 -O ";

      "max_fingerprint_entries" string => "10000";

      "apt_key_list_tmpstring" string => execresult("$(apt_key_list_cmd)","useshell");
      "apt_key_current_list" slist => splitstring("$(apt_key_list_tmpstring)", "$(const.n)", "$(max_fingerprint_entries)");

      "keyfile_local_dir" string => "$(sys.workdir)/state/security/apt_keyfiles/";

      "keyfile" string => "$(keyfile_local_dir)$(i).key",
        ifvarclass => "key_$(i)_not_in_list";
      
  classes:
      "key_$(i)_not_in_list" expression => none( "$(repo[$(i)][keyfile_fingerprint])", "$(apt_key_current_list)" );

      "keyfile_$(i)_exists" expression => fileexists( "$(keyfile[$(i)])" );
      
  commands:
    # debian::
    #   "$(wget_cmd) $(keyfile[$(i)]) $(keyfile_link[$(i)])"
    # 	contain => in_shell,
    #     classes => results("bundle", "apt_key_add"),
    #     comment => "use apt-key to add new repository key file",
    #     ifvarclass => "key_$(i)_not_in_list",
    #     unless => "keyfile_$(i)_exists";

    # debian::
    #   "$(apt_key_add_cmd) $(keyfile[$(i)])"
    # 	contain => in_shell,
    #     classes => results("bundle", "apt_key_add"),
    #     comment => "use apt-key to add new repository key file",
    #     ifvarclass => "key_$(i)_not_in_list.keyfile_$(i)_exists";

      
  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";
      

    (DEBUG|DEBUG_testing)::
      "=== $(this.bundle) ===";
      "current fingerprints in apt-key: $(apt_key_current_list)";

      "Will run: $(wget_cmd) $(keyfile[$(i)]) $(keyfile_link[$(i)])"
        ifvarclass => "key_$(i)_not_in_list",
        unless => "keyfile_$(i)_exists";

      "Will run: $(apt_key_add_cmd) $(keyfile[$(i)])"
        ifvarclass => and( "key_$(i)_not_in_list", "keyfile_$(i)_exists" );
            
}


######################################################################

bundle agent wipe(runenv, metadata, wipe, given_file)
# @description: removing entries in /etc/apt/sources.list or /etc/apt/sources.list.d/*.list
{
  classes:
      # "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
      # "not_$(vars)" expression => "!default:runenv_$(runenv)_$(vars)";

  vars:
      # "vars" slist => { "@(default:$(runenv).env_vars)" };
      # "$(vars)" string => "$(default:$(runenv).$(vars))";

      # "file" string => "$(default:eu.path_prefix)$(given_file)",
      #   policy => "free";

      "class_prefix" string => canonify($(file)),
        policy => "free";

  methods:
#      "utils" usebundle => default:eu($(runenv));

#    verbose::
#      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
#        inherit => "true";

  files:
      "$(file)"
        delete  => default:tidy,
        classes => default:classes_generic("$(class_prefix)_wipe"),
        comment => "Wipe $(file)";

  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
        ifvarclass => "$(vars)";

      "$(this.bundle): wiping file $(file)";

    cfengine::
      "$(file)" bundle_return_value_index => "file";
}

