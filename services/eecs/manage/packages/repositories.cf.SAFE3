##############################################################################
#
#   manage/packages/repositories.cf - EECS package repository configuration
#   Maintained: Ben Roose, ver 0.1
#
###############################################################################



# PROTIP: Use body file control to help make modular policy.
# "There can be only one" body common control per policy entry (promises.cf,update.cf)

# TESTING ONLY:INPUT STANDARD LIBRARY and HOST CLASSIFICATION (Remove after testing)
body file control
{
      inputs => { "$(sys.libdir)/stdlib.cf",
		  "$(sys.workdir)/inputs/services/eecs/classification/host_role/main.cf" };
}

######################################################################
# Public entry point: config_apt_sources
######################################################################

# NOTES for future development of configuration:
# 1.

bundle agent config_apt_sources
# @description: takes in repository info from external json file and adds or removes repository within /etc/apt/sources
# WORKING ON IT
{
  vars:
    # server::
      "sources_file" string => "/tmp/sources.list";
      
      "options" string => "";

      "repositories_file" string => "$(this.promise_dirname)/data/repos.json";
      "repositories_data" data => readjson( $(repositories_file), 10M );
      "json_str" string => format("%S", repositories_data);

      "repos_ensure" data => mergedata("repositories_data[repos_to_ensure]");
      "repos_wipe" data => mergedata("repositories_data[repos_to_wipe]");      
     "json_str_ensure" string => format("%S", repos_ensure);

      "i_unsorted" slist => getindices("repos_ensure");
      "index_ensure" slist => sort("i_unsorted",int),
      comment => "build a sorted index list of all ensured repos";

      "each_repo" data => mergedata("repos_ensure[$(index_ensure)]");

      
      "context_ensure[$(index_ensure)]" string => "any",
        ifvarclass => not(isvariable("repos_ensure[$(index_ensure)][context]"));
      "context_ensure[$(index_ensure)]" string => "$(repos_ensure[$(index_ensure)][context])",
        ifvarclass => and(isvariable("repos_ensure[$(index_ensure)][context]")),
      comment => "set context class for each ensure entry or set as any if not defined";
      
      "component_list" slist => getvalues( "repos_ensure[$(index_ensure)][components]" );
      "type_list[$(index_ensure)]" slist => getvalues( "repos_ensure[$(index_ensure)][types]" );
      
  methods:

      #"call it" usebundle => testing(@(repos_ensure));

        "ensure all required repos are inserted into sources.list as specified in repos.json"
        	usebundle => ensure( $(sources_file), @(each_repo), $(options) ),
          inherit => "true";
        # ifvarclass => and( "$(context_ensure[$(index_ensure)])" );

        # "ensure all required repos are inserted into sources.list as specified in repos.json"
        # 	usebundle => ensure( $(sources_file), @(repos_ensure), $(index_ensure), $(options) ),
        #   inherit => "true";
      # "remove all required repos from sources.list as specified in repos.json"
      # 	usebundle => wipe( $(sources_file), $(repos_wipe[url]), $(repos_wipe[distribution]), $(repos_wipe[components]), $(repos_wipe[types]), $(options)),
      #   inherit => "true";

  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";
      

    (DEBUG|DEBUG_testing)::
      "=== $(this.bundle) ===";
      "Repository to be ensured: $(index_ensure) = $(each_repo[comment])"
        ifvarclass => and( "$(context_ensure[$(index_ensure)])" );

      #"Repository types: $(index_ensure) = $(type_list[$(index_ensure)])";

      # "$(sources_file) $(repos_ensure[$(index_ensure)][url]) $(repos_ensure[$(index_ensure)][distribution]) $(repos_ensure[$(index_ensure)][components]) $(repos_ensure[$(index_ensure)][types]) $(options)";
      # "context = $(context_ensure[$(index_ensure)])";
      # "Contents of 'json_input' data container: '$(json_str)'";  
      # "Contents of 'json_input_ensure' data container: '$(json_str_ensure)'";  

}

######################################################################

bundle agent ensure(file, repo, options)
# @description: enforcing entries in /etc/apt/sources.list or /etc/apt/sources.list.d/*.list
{
#  classes:
#      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)"
#      "not_$(vars)" expression => "!default:runenv_$(runenv)_$(vars)";

  vars:
#      "vars" slist => { "@(default:$(runenv).env_vars)" };
#      "$(vars)" string => "$(default:$(runenv).$(vars))";

      "CFEnotice"
        string  => "# This file is managed by CFEngine, manual edits will be reverted",
        comment => "It's nice to let people know why the file keep magically reverting on them";

      # "i_unsorted" slist => getindices("repo");
      # "i" slist => sort("i_unsorted",int),
      # comment => "build a sorted index list of all ensured repos";
      
      # "context_ensure[$(i)]" string => "any",
      #   ifvarclass => not(isvariable("repo[$(i)][context]"));
      # "context_ensure[$(i)]" string => "$(repo[$(i)][context])",
      #   ifvarclass => and(isvariable("repo[$(i)][context]")),
      # comment => "set context class for each ensure entry or set as any if not defined";

      "components_str" string => join(" ", "repo[components]");

      # "file" string => "$(default:eu.path_prefix)$(given_file)",
      #   policy => "free";

      "class_prefix" string => canonify($(file)),
        policy => "free";

#      "entries" slist => maplist( "$(this)", "repo[$(i)][types]" );

      "entries" slist => maplist( "$(this) $(options) $(repo[url]) $(repo[distribution]) $(components_str)", "repo[types]" );

      # "entries" slist => maplist("$(this) $(options) $(url) $(distribution) $(components_str)", "types");
      #"entries" slist => maplist("Test $(this)", "types");

      # methods:
  #     "utils" usebundle => default:eu($(runenv));

    # verbose::
    #   "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
    #     inherit => "true";

  files:
#    activated::
      "$(file)"
        create        => "true",
        perms         => m("0644"),
        edit_defaults => empty,
        edit_line     => sources_list( $(CFEnotice), @(entries) ),
        classes       => classes_generic("$(class_prefix)_ensure"),
        comment       => "Create $(file) and note that the file is managed by CFEngine";

  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_testing)::
      "=== $(this.bundle) ===";

    # verbose::
    #   "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
    #   "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
    #     ifvarclass => "$(vars)";

      "sources file $(file) ensuring line = $(entries)";
#      "sources file $(file) ensuring line = $(entries)";

    # cfengine::
    #   "$(file)" bundle_return_value_index => "file",
    #     ifvarclass => canonify("$(class_prefix)_ensure_ok");

    #   "" bundle_return_value_index => "file",
    #     ifvarclass => canonify("$(class_prefix)_ensure_not_ok");
}

######################################################################

bundle edit_line sources_list( header, lines )
{
#  delete_lines:
#      ".*";
  insert_lines:
      "$(header)";
      "$(lines)";
}

######################################################################

bundle agent wipe(runenv, metadata, wipe, given_file)
# @description: removing entries in /etc/apt/sources.list or /etc/apt/sources.list.d/*.list
{
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
      "not_$(vars)" expression => "!default:runenv_$(runenv)_$(vars)";

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

      "file" string => "$(default:eu.path_prefix)$(given_file)",
        policy => "free";

      "class_prefix" string => canonify($(file)),
        policy => "free";

  methods:
      "utils" usebundle => default:eu($(runenv));

#    verbose::
#      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
#        inherit => "true";

  files:
      "$(file)"
        delete  => default:tidy,
        classes => default:classes_generic("$(class_prefix)_wipe"),
        comment => "Wipe $(file)";

  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
        ifvarclass => "$(vars)";

      "$(this.bundle): wiping file $(file)";

    cfengine::
      "$(file)" bundle_return_value_index => "file";
}


bundle agent testing(repo)
{
  vars:
      "i_unsorted" slist => getindices("repo");
      "index_ensure" slist => sort("i_unsorted",int),
      comment => "build a sorted index list of all ensured repos";

  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_testing)::
      "=== $(this.bundle) ===";
      "$(this.bundle): $(index_ensure) [context] = $(repo[comment][$(index_ensure)])";
      "$(i_unsorted) [context]";

      "Comment for ensured repo $(repos[$(index_ensure)][comment])";

}
