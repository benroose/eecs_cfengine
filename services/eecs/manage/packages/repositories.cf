##############################################################################
#
#   manage/packages/repositories.cf - EECS package repository configuration
#   Maintained: Ben Roose, ver 0.1
#
###############################################################################



# PROTIP: Use body file control to help make modular policy.
# "There can be only one" body common control per policy entry (promises.cf,update.cf)

# TESTING ONLY:INPUT STANDARD LIBRARY and HOST CLASSIFICATION (Remove after testing)
body file control
{
      inputs => { "$(sys.libdir)/stdlib.cf",
		  "$(sys.workdir)/inputs/services/eecs/classification/host_role/main.cf" };
}

######################################################################
# Public entry point: config_apt_sources
######################################################################

# NOTES for future development of configuration:
# 1.

bundle agent config_apt_sources
# @description: takes in repository info from external json file and adds or removes repository within /etc/apt/sources
# WORKING ON IT
{
  vars:
#    server::
      "repositories_file" string => "$(this.promise_dirname)/repositories.json";

#    workstation::
#      "iptables_rules_file" string => "$(this.promise_dirname)/iptables_rules_workstation.json";

    any::
      "repositories_data"
        data => readjson( $(repositories_file), 10M );

#      "chain_policies" data => mergedata("iptables_data[chain_policies]");      
#      "filter_rules" data => mergedata ("iptables_data[filter_rules]");

      "json_str" string => format("%S", repositories_data);
      # json_str is just for printing seralized version of data container for debugging (note it is JSON).

#      "_cache_dir" string => "$(sys.workdir)/state/security/iptables/filter";

#      "entries" slist => maplist("$(this) $(options) $(url) $(distribution) $(components_str)", "types");

      
  # security_rules::
  #   "security_classes" slist => getvalues( "classify_host.security_rules" ),
  #   comment => "list of custom security rules from host_data.json file.";
  #   "security_rules_json_str" string => format("%S", "classify_host.security_rules");

  # classes:      
  #     "$(security_classes)"
  # 	expression => isvariable ("security_classes"),
  #       scope => "namespace",
  #       comment => "create classes from values within security classes/rules list";
      
  files:
      "$(_cache_dir)/."
      create => "true";
      #handle => "iptables_create_cache_dir";

      "$(iptables_rules_file)"
      changes => detect_content_change,
      classes => results("bundle", "iptables_rules_change"),
      comment => "check if rules policy file content has changed and set repaired class if changed";     
      
  methods:
    any::      
      "save current iptables filters and check for changes"
	usebundle => iptables_check($(_cache_dir)),
        inherit => "true";
            
    iptables_rules_change_repaired|iptables_current_change_repaired::
      "if either policy file or iptables has changed, generate new filter policy and restore to iptables"
	usebundle => iptables_generate_policy($(_cache_dir), @(chain_policies), @(filter_rules)),
        inherit => "true";

#      "NOT USED - delete temporary files"
#        inherit => "true",
#        usebundle => iptables_tidy($(_cache_dir));
      
  reports:
   (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";
      
    (DEBUG|DEBUG_main)::
      # "Contents of 'json_input' data container: '$(json_str)'";  

    (DEBUG|DEBUG_testing).security_rules::
      "$(this.bundle): Security rule found $(security_classes)";
}

######################################################################

bundle agent ensure(runenv, metadata, given_file, url, distribution, components, types, options)
# @description: enforcing entries in /etc/apt/sources.list or /etc/apt/sources.list.d/*.list
{
#  classes:
#      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
#      "not_$(vars)" expression => "!default:runenv_$(runenv)_$(vars)";

  vars:
#      "vars" slist => { "@(default:$(runenv).env_vars)" };
#      "$(vars)" string => "$(default:$(runenv).$(vars))";

      "CFEnotice"
        string  => "# This file is managed by CFEngine, manual edits will be reverted",
        comment => "It's nice to let people know why the file keep magically reverting on them";

      "components_str" string => join(" ", "components");

      "file" string => "$(default:eu.path_prefix)$(given_file)",
        policy => "free";

      "class_prefix" string => canonify($(file)),
        policy => "free";

      "entries" slist => maplist("$(this) $(options) $(url) $(distribution) $(components_str)", "types");

  methods:
      "utils" usebundle => default:eu($(runenv));

    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
        inherit => "true";

  files:
    activated::
      "$(file)"
        create        => "true",
        perms         => default:m("0644"),
        edit_defaults => default:empty,
        edit_line     => sources_list($(CFEnotice), @(cfdc_aptrepo:ensure.entries)),
        classes       => default:classes_generic("$(class_prefix)_ensure"),
        comment       => "Create $(file) and note that the file is managed by CFEngine";

  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
        ifvarclass => "$(vars)";

      "$(this.bundle): file $(file); ensuring line $(entries)";

    cfengine::
      "$(file)" bundle_return_value_index => "file",
        ifvarclass => canonify("$(class_prefix)_ensure_ok");

      "" bundle_return_value_index => "file",
        ifvarclass => canonify("$(class_prefix)_ensure_not_ok");
}

######################################################################

bundle edit_line sources_list( header, lines )
{
  delete_lines:
      ".*";
  insert_lines:
      "$(header)";
      "$(lines)";
}

######################################################################

bundle agent wipe(runenv, metadata, wipe, given_file)
# @description: removing entries in /etc/apt/sources.list or /etc/apt/sources.list.d/*.list
{
  classes:
      "$(vars)" expression => "default:runenv_$(runenv)_$(vars)";
      "not_$(vars)" expression => "!default:runenv_$(runenv)_$(vars)";

  vars:
      "vars" slist => { "@(default:$(runenv).env_vars)" };
      "$(vars)" string => "$(default:$(runenv).$(vars))";

      "file" string => "$(default:eu.path_prefix)$(given_file)",
        policy => "free";

      "class_prefix" string => canonify($(file)),
        policy => "free";

  methods:
      "utils" usebundle => default:eu($(runenv));

    verbose::
      "metadata" usebundle => default:report_metadata($(this.bundle), $(metadata)),
        inherit => "true";

  files:
      "$(file)"
        delete  => default:tidy,
        classes => default:classes_generic("$(class_prefix)_wipe"),
        comment => "Wipe $(file)";

  reports:
    verbose::
      "$(this.bundle): imported environment '$(runenv)' var '$(vars)' with value '$($(vars))'";
      "$(this.bundle): imported environment '$(runenv)' class '$(vars)' because 'default:runenv_$(runenv)_$(vars)' was defined"
        ifvarclass => "$(vars)";

      "$(this.bundle): wiping file $(file)";

    cfengine::
      "$(file)" bundle_return_value_index => "file";
}
