##############################################################################
#
#   manage/<service>/main.cf - EECS <service> configuration
#   Maintained: Ben Roose, ver 0.1
#
###############################################################################



# PROTIP: Use body file control to help make modular policy.
# "There can be only one" body common control per policy entry (promises.cf,update.cf)

# TESTING ONLY:INPUT STANDARD LIBRARY and HOST CLASSIFICATION (Remove after testing)
body file control
{
      inputs => { "$(sys.libdir)/stdlib.cf",
		  "$(sys.workdir)/inputs/services/eecs/classification/host_role/main.cf" };
}

######################################################################
# Public entry point: web_server(on) OR web_server(off)
######################################################################

# NOTES for future development of configuration:
# 1.

# bundle agent web_server
bundle agent web_server(state)
# @description: installs and configures an apache2 web server with SSL CA Certs from Let's Encrypt using certbot
# NOTE: uses the CFE service state on/off for enabling configuration!!
{

  vars:      
      "apache_exec" string => "/usr/sbin/apache2";

  classes:
      # REMOVE testing_cert once fully ready for production deployment!
      "testing_cert"  expression => "any";

      # DEFINE SERVER STATES
      # "on"  expression => "any";
      "on"  expression => strcmp("$(state)","on");
      "off" expression => strcmp("$(state)","off");

      "apache_exists"
	expression => fileexists( "$(apache_exec)" );

  methods:

    off.apache_exists::
      "ensure apache2 service is stopped if web_server is off"
      	usebundle => standard_services( "apache2", "stop" ),
      	classes => if_ok("web_server_off");

    ## ENSURE SERVICES ARE RUNNING AND CONFIGURED
    on.apache_exists::
      "ensure apache2 service is running if web_server is on"
      	usebundle => standard_services( "apache2", "start" ),
      	classes => if_ok("web_server_on");

      "generate all web server variables"  usebundle => web_server_vars;
      
      "generate virtual host site config files from templates"
    	usebundle => generate_sites("web_server_vars.conf"),
        classes => results("bundle", "sites_generated");
      
    ## ENABLE SITES/MODULES AND GENERATING SSL CERTIFICATES
    on.sites_generated_repaired::
      "enable apache sites"
    	usebundle => manage_apache_site("$(web_server_vars.conf[sites_enabled])", enable),
        classes => results("bundle", "enable_site");

      "enable apache modules"
    	usebundle => manage_apache_module("$(web_server_vars.install[modules_enabled])", enable),
        classes => results("bundle", "enable_module");

      "reload apache2 service after generating and enabling new sites"
      	usebundle => standard_services( "apache2", "reload" ),
      	classes => if_ok("web_server_reload");

      "install SSL/TLS certificates using EFF certbot"
      	usebundle => manage_certbot("web_server_vars.conf", install),
        classes => results("bundle", "install_certs");

    on.enable_module_repaired::
      "restart apache2 service after enabling new modules"
      	usebundle => standard_services( "apache2", "restart" ),
      	classes => if_ok("web_server_restart");

    ## INSTALL ALL SOFTWARE FOR WEB SERVER
    on.install_software::
      "generate all web server variables"  usebundle => web_server_vars;

      "install dependent packages"
    	usebundle => package_latest("$(web_server_vars.install[dependent_packages])"),
        classes => results("bundle", "dependent_packages_install");
        # classes => if_ok("software_ok");

      "disable default apache testing site"
    	usebundle => manage_apache_site("$(web_server_vars.conf[apache_default_site])", disable),
        classes => results("bundle", "disable_default_site");

    ## SSL CERTIFICATE RENEWAL
    on.ssl_cert_renew::
      "check if SSL/TLS certificates need to be renewed (set cert_renew class in cron_scheduler for once a week)"
    	usebundle => manage_certbot("web_server_vars.conf", renew),
        classes => results("bundle", "renew_certs");
      
  reports:
    (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_web_server)::
      "=== $(this.bundle) ===";

      "web server (apache2) is not installed on this host"
        ifvarclass => "!apache_exists";
      "web server is turned off"
        ifvarclass => "web_server_off";
      "web server is turned on and running"
        ifvarclass => "web_server_on";
      "web server restarted due to configuration change"
        ifvarclass => "web_server_restart";
      "web server reloaded due to configuration change"
        ifvarclass => "web_server_reload";

      "site generated from templates and enabled: $(web_server_vars.conf[sites_enabled])"
        ifvarclass => "enable_sites_repaired";
      "module enabled: $(web_server_vars.install[modules_enabled])"
        ifvarclass => "enable_modules_repaired";
      "$(web_server_vars.install[dependent_packages]) installed"
        ifvarclass => "dependent_packages_install_repaired";

}

######################################################################

bundle agent web_server_vars(params1, params2)
{
  vars:

    ## INSTALL PARAMETERS FOR ALL SOFTWARE
    debian::
      "install[dependent_packages]" slist => { "apache2", "certbot", "python-certbot-apache", },
        comment => "set of packages for apache web server and let's encrypt SSL certbot";

      "install[modules_enabled]" slist => { "ssl", "proxy", "proxy_http", "proxy_wstunnel", },
        comment => "set of modules to enable for ssl and proxy";
        # original modules required: mod_proxy and mod_proxy_wstunnel. Debian removes the 'mod_'

    ## EFF LET'S ENCRYPT CERTBOT CONFIGURATION PARAMETERS
      "conf[certbot_config_file]" string => "/etc/letsencrypt/cli.ini";
      "conf[certbot_config_template]" string => "$(this.promise_dirname)/data/certbot_config.tpl.txt";
      "conf[certbot_registered_email]" string => "root@cs.wichita.edu";
      "conf[certbot_cert_dir]" string => "/etc/letsencrypt/live/"; #certs are in each domain subdirectory

      "conf[certbot_include_path]" string => "/etc/letsencrypt/options-ssl-apache.conf";
      "conf[certbot_cert_chain_file]" string => "fullchain.pem";
      "conf[certbot_cert_key_file]" string => "privkey.pem";
      "conf[certbot_domains_to_register]" string => "testing-guac.cs.wichita.edu";

      "conf[apache_serveradmin_email]" string => "root@cs.wichita.edu";
      "conf[apache_available_sites_dir]" string => "/etc/apache2/sites-available/";
      "conf[apache_site_index_file]" string => "index.html";
      "conf[apache_site_index_template]" string => "$(this.promise_dirname)/data/default_index_html.tpl.txt";
      "conf[apache_default_site]" string => "000-default.conf";

      "conf[apache_root_dir]" string => "/var/www/";
      # NOTE: if you move root dir location to different from /var/www, then you need to
      # whitelist the location in /etc/apache2/apache2.conf

    ## GUACAMOLE PROXY VIRTUAL HOST CONFIGURATION PARAMETERS
      "conf[site_data][guac][site_file]" string => "guacamole.conf";
      "conf[site_data][guac][site_template]" string => "$(this.promise_dirname)/data/guacamole_proxy.tpl.txt";
      "conf[site_data][guac][domain_hostname]" string => "testing-guac.cs.wichita.edu";
      "conf[site_data][guac][document_root]" string => "$(conf[apache_root_dir])/guacamole/public_html/";
      "conf[site_data][guac][custom_apache_log]" string => "/var/log/apache2/guac.log";

    ## TESTING ONLY INSECURE AND SSL VIRTUAL HOST CONFIGURATION PARAMETERS
      # "conf[site_data][test][site_file]" string => "testing_insecure.conf";
      # "conf[site_data][test][site_template]" string => "$(this.promise_dirname)/data/testing_insecure.tpl.txt";

      # "conf[site_data][test][site_file]" string => "testing_ssl.conf";
      # "conf[site_data][test][site_template]" string => "$(this.promise_dirname)/data/testing_ssl.tpl.txt";
      # "conf[site_data][test][domain_hostname]" string => "testing-guac.cs.wichita.edu";
      # "conf[site_data][test][document_root]" string => "$(conf[apache_root_dir])/testing/public_html/";
      # "conf[site_data][test][custom_apache_log]" string => "/var/log/apache2/testing.log";

      
    ## VIRTUAL HOST SITES ENABLED IN WEB SERVER
      "conf[sites_enabled]" slist => { "$(conf[site_data][guac][site_file])" };
      # "conf[sites_enabled]" slist => { "$(conf[site_data][test][site_file])" };
      
    any::
      # Copy configuration parameters passed, into a local array
      "param1_keys"          slist  => getindices("$(params1)");   
      "param2_keys"          slist  => getindices("$(params2)");   
      "install[$(param1_keys)]" string => "$($(params1)[$(param1_keys)])";
      "conf[$(param2_keys)]" string => "$($(params2)[$(param2_keys)])";

      
  reports:
    (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";
}

######################################################################

bundle agent manage_certbot(params, action)
# @description: run EFF Let's Encrypt certbot for SSL/TLS certificate deployment
{
  vars:
    debian::
      "site_keys_unsorted" slist => getindices("$(params)[site_data]");
      "site_keys" slist => sort( site_keys_unsorted, "lex" );
      "$(site_keys)_domain_hostname" string => "$($(params)[site_data][$(site_keys)][domain_hostname])";

      "certificate_dir" string => "$($(params)[certbot_cert_dir])";
      "cert_filename" string => "cert.pem";

      "certbot_exec" string => "/usr/bin/certbot";

    !testing_cert::
      "certbot_install_cmd" string => "$(certbot_exec) run --apache --non-interactive --config ";
      "certbot_renew_cmd" string => "$(certbot_exec) renew --non-interactive";
      "certbot_revoke_cmd" string => "$(certbot_exec) revoke --non-interactive --cert-path ";

    testing_cert::
      "certbot_install_cmd" string => "$(certbot_exec) run --testing --apache --config ";
      "certbot_renew_cmd" string => "$(certbot_exec) renew --testing --non-interactive --config ";
      "certbot_revoke_cmd" string => "$(certbot_exec) revoke --testing --non-interactive --cert-path ";
      

  classes:
      "install_cert"  expression => strcmp("$(action)","install");
      "renew_cert" expression => strcmp("$(action)","renew");
      "revoke_cert" expression => strcmp("$(action)","revoke");

      "certbot_exists"
	expression => fileexists( "$(certbot_exec)" );

      "certbot_config_exists"
	expression => fileexists( "$($(params)[certbot_config_file])" );

      "certificate_for_domain_exists"
	expression => fileexists( "$(certificate_dir)/$(domain_hostnames[$(domains)])/$(cert_filename)" );

  files:
    ## SET CERTBOT CONFIGURATION FROM TEMPLATE
      "$($(params)[certbot_config_file])"
        create => "true",
        edit_template => "$($(params)[certbot_config_template])",
	# action => if_elapsed("60"),
        classes => results("bundle", "certbot_config"),
	comment => "expand certbot config file using template from staging cache in this promise directory";

  commands:
    ## CERTBOT CERTIFICATE COMMANDS
    install_cert.!certificate_for_domain_exists.certbot_exists.certbot_config_exists.debian::
      "$(certbot_install_cmd) $($(params)[certbot_config_file])"
        classes => results("bundle", "certbot_install"),
        comment => "run certbot to install apache SSL certificates using config file";

    renew_cert.certbot_exists.debian::
      "$(certbot_renew_cmd)"
        classes => results("bundle", "certbot_renew"),
        comment => "run certbot to check for SSL certificate renewal";

    revoke_cert.certbot_exists.debian::
      "$(certbot_revoke_cmd) $($(params)[certbot_cert_dir])/DOMAIN??/$(cert_filename)"
        classes => results("bundle", "certbot_renew"),
        comment => "run certbot to check for SSL certificate renewal";
      
  reports:
    (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_web_server)::
      "=== $(this.bundle) ===";

      "certbot config not found at $($(params)[certbot_config_file])"
        ifvarclass => "!certbot_config_exists";

      "certbot has certificate for domain: $(domain_hostnames[$(domains)])"
        ifvarclass => "certificate_for_domain_exists";
      "certbot installed apache SSL certificates using config file $($(params)[certbot_config_file])"
        ifvarclass => "certbot_install_repaired";

      "certbot run to check for SSL certificate renewal"
        ifvarclass => "certbot_renew_repaired";
}

######################################################################

bundle agent generate_sites(params)
# @description: generate virtual host site .conf and index.html files from templates
{
  vars:
    debian::
      "site_keys_unsorted" slist => getindices("$(params)[site_data]");
      "site_keys" slist => sort( site_keys_unsorted, "lex" );
      "$(site_keys)_site_file" string => "$($(params)[site_data][$(site_keys)][site_file])";
      "$(site_keys)_site_template" string => "$($(params)[site_data][$(site_keys)][site_template])";
      "$(site_keys)_document_root" string => "$($(params)[site_data][$(site_keys)][document_root])";
      
      "sites_dir" string => "$($(params)[apache_available_sites_dir])";
      "site_index_file" string => "$($(params)[apache_site_index_file])";
      "site_index_template" string => "$($(params)[apache_site_index_template])";

  classes:

  files:
    ## BUILD AVAILABLE SITE CONF FILE AND DEFAULT INDEX.HTML FILE FROM TEMPLATES
      "$($(site_keys)_document_root)/."
        create => "true",
	perms => mog("755", "root", "root" ),
        comment => "ensure the site document root directory has been created and is globally readable";

      "$(sites_dir)/$($(site_keys)_site_file)"
        create => "true",
	perms => mog("644", "root", "root" ),
        edit_template => "$($(site_keys)_site_template)",
        classes => results("bundle", "$(site_keys)_file_create"),
      	comment => "expand site file in available sites directory using template from staging cache in this promise dir";
      
      "$($(site_keys)_document_root)/$(site_index_file)"
        create => "true",
	perms => mog("644", "root", "root" ),
        edit_template => "$(site_index_template)",
        classes => results("bundle", "$(site_keys)_index_create"),
      	comment => "expand default index.html in site document root directory using template from staging cache in this promise dir";

  reports:
    (inform_mode|verbose_mode)::
      "$(this.bundle): Activated";

    (DEBUG|DEBUG_web_server)::
      "=== $(this.bundle) ===";

      "Directory to store available sites: $(sites_dir)";
      "Found $(site_keys) file: $($(site_keys)_site_file) using template: $($(site_keys)_site_template)";
      "Directory for site documents root: $($(site_keys)_document_root)";
      "Site configuration file generated: $($(site_keys)_site_file)"
        ifvarclass => "$(site_keys)_file_create_repaired";
      "Site testing index file generated: $($(site_keys)_document_root)/$(site_index_file)"
        ifvarclass => "$(site_keys)_index_create_repaired";

      # "DEBUG: site_files $(site_data[$(site_keys)][site_file])";
      # "DEBUG: template_files $(site_data[$(site_keys)][template_file])";
}

######################################################################

bundle agent manage_apache_module(module, action)
# @description: enable or disable apache module
{
  vars:

  classes:
      "enable"  expression => strcmp("$(action)","enable");
      "disable" expression => strcmp("$(action)","disable");
      
  commands:
    enable.debian::
      "/usr/sbin/a2enmod $(module)"
        comment => "use debian a2enmod to enable apache module";

    disable.debian::
      "/usr/sbin/a2dismod $(module)"
        comment => "use debian a2enmod to disable apache module";
}

######################################################################

bundle agent manage_apache_site(site, action)
# @description: enable or disable apache virtual host sites
{
  vars:

  classes:
      "enable"  expression => strcmp("$(action)","enable");
      "disable" expression => strcmp("$(action)","disable");
      
  commands:
    enable.debian::
      "/usr/sbin/a2ensite $(site)"
        comment => "use debian a2ensite to enable apache virtual host site";

    disable.debian::
      "/usr/sbin/a2dissite $(site)"
        comment => "use debian a2enmod to disable apache virtual host site";
}

######################################################################

